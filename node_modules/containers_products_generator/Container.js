const fs = require("fs");
const path = require("path")
const schema_product = require('./schemaValidation')
const { v4: uuidv4 } = require("uuid")
const moment=require('moment')
const writeFileAsync = async (arr) => {
    await fs.promises.writeFile(
        "./productos.txt",
        JSON.stringify(arr, null, 2),
        "utf-8"
    );
};

const readFileAsync = async (arr) => {
    let file = await fs.promises.readFile("./productos.txt", "utf-8");
    return file;
};
const verifyExistence = file => file && file.length >= 0 ? true : false

module.exports = class Product {
    constructor() {
        this.pr = [];
    }

    async save(product) {
        try {
            let fileExits = await readFileAsync(); //String
            if (verifyExistence(fileExits)) {
                let dataFile = JSON.parse(fileExits);
                product.id = uuidv4()
                product.timestmap = moment(Date.now()).format('MMMM Do YYYY, h:mm:ss a')
                const value = schema_product.validate(product)
                dataFile.push(product);
                this.pr = dataFile;
                writeFileAsync(this.pr);
                return product.id
            }
        } catch (e) {
            product.id = uuidv4()
            product.timestmap = moment(Date.now()).format('MMMM Do YYYY, h:mm:ss a')
            this.pr.push(product)
            writeFileAsync(this.pr)
            return product.id
        }
    }


    async getById(id) {
        let fileExits = await readFileAsync(); // tipo de dato string
        if (fileExits && fileExits.length >= 0) {
            let dataFile = JSON.parse(fileExits);
            for (let d of dataFile) {
                if (d.id === id) {
                    return d;
                }
            }
        }
        return null

    }
    async updateById(id, name, description, url, price, stock) {
        let fileExits = await readFileAsync(); // tipo de dato string
        if (fileExits && fileExits.length >= 0) {
            let dataFile = JSON.parse(fileExits); // type object
            for (let d of dataFile) {
                if (d.id === id) {
                    d.name = name
                    d.description = description
                    d.url = url
                    d.price = price
                    d.stock = stock
                    this.pr=dataFile
                    writeFileAsync(dataFile)
                    return d;
                }
                
            }
            
        }
        return null

    }
    async getAll() {
        let fileExits = await readFileAsync(); // tipo de dato string
        if (fileExits && fileExits.length >= 0) {
            let dataFile = JSON.parse(fileExits);
            return dataFile
        }
        throw " get-All No se encontro archivo"
    }

    async deleteByID(id) {
        let fileExits = await readFileAsync(); // tipo de dato string
        if (verifyExistence(fileExits)) {
            let dataFile = JSON.parse(fileExits); // objecto
            let idExist = dataFile.filter(d => d.id == id) // Devuelve un Array/ si no existe devuelve un array vacio
            let newElements = dataFile.filter(d => d.id !== id)
            if (idExist.length > 0) {
                writeFileAsync(newElements)
                return console.log(`This the new list of product´s
                ${JSON.stringify(newElements, null, 2)}`)
            }
            throw `theres no such id in the repo, but you can see all the products below:
            ${JSON.stringify(dataFile, null, 2)}`
        }
        throw "delete-by-id No se encontro archivo"
    }

    async deleteAll() {
        let fileExits = await readFileAsync(); // tipo de dato string
        if (fileExits && fileExits.length >= 0) {
            this.pr = []
            await fs.promises.rm(path.join(__dirname, "/productos.txt"))
            return `The Elements has been deleted`
        }
        throw "No se encontro archivo"
    }
}
/* module.exports = class Cart {
    constructor() {
        this.pr = [];
    }

    async save(product) {
        let fileExits = await readFileAsync(); //String
        if (verifyExistence(fileExits)) {
            let dataFile = JSON.parse(fileExits);
            product.id = id
            product.timestmap = Date.now()
            const value = schema_product.validate(product)
            dataFile.push(product);
            this.pr = dataFile;
            writeFileAsync(this.pr);
            return product.id
        }
        product.id = id
        product.timestmap = Date.now()
        this.pr = product
        writeFileAsync(product)
        return product.id
    }


    async getById(id) {
        let fileExits = await readFileAsync(); // tipo de dato string
        if (fileExits && fileExits.length >= 0) {
            let dataFile = JSON.parse(fileExits);
            for (let d of dataFile) {
                if (d.id === id) {
                    return d;
                }
            }
        }
        return null

    }
    async updateById(id, name, description, url, price, stock) {
        let fileExits = await readFileAsync(); // tipo de dato string
        if (fileExits && fileExits.length >= 0) {
            let dataFile = JSON.parse(fileExits); // type object
            for (let d of dataFile) {
                if (d.id === id) {
                    d.name = name
                    d.description = description
                    d.url = url
                    d.price = price
                    d.stock = stock
                    return d;
                }
            }
        }
        return null

    }
    async getAll() {
        let fileExits = await readFileAsync(); // tipo de dato string
        if (fileExits && fileExits.length >= 0) {
            let dataFile = JSON.parse(fileExits);
            return dataFile
        }
        throw " get-All No se encontro archivo"
    }

    async deleteByID(id) {
        let fileExits = await readFileAsync(); // tipo de dato string
        if (verifyExistence(fileExits)) {
            let dataFile = JSON.parse(fileExits); // objecto
            let idExist = dataFile.filter(d => d.id == id) // Devuelve un Array/ si no existe devuelve un array vacio
            let newElements = dataFile.filter(d => d.id !== id)
            if (idExist.length > 0) {
                writeFileAsync(newElements)
                return console.log(`This the new list of product´s
                ${JSON.stringify(newElements, null, 2)}`)
            }
            throw `theres no such id in the repo, but you can see all the products below:
            ${JSON.stringify(dataFile, null, 2)}`
        }
        throw "delete-by-id No se encontro archivo"
    }

    async deleteAll() {
        let fileExits = await readFileAsync(); // tipo de dato string
        if (fileExits && fileExits.length >= 0) {
            this.pr = []
            await fs.promises.rm(path.join(__dirname, "/productos"))
            return `The Elements has been deleted`
        }
        throw "No se encontro archivo"
    }
} */